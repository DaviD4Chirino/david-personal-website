---
import { getCollection, type CollectionEntry } from "astro:content";
import BlogCard from "../templates/BlogCard.astro";
import {
  sortAlphabetically,
  sortByNumberSize,
  stringIncludes,
} from "../../utils";
import { DateTime } from "luxon";

interface Props {
  revese?: boolean;
  orderBy?: orders;
  maxPosts?: number;
}

type Filters = {
  [type in orders]: (
    a: CollectionEntry<"posts">,
    b: CollectionEntry<"posts">
  ) => number;
};

const filters: Filters = {
  date: (a: CollectionEntry<"posts">, b: CollectionEntry<"posts">): number =>
    sortByNumberSize(
      DateTime.fromFormat(a.data.date, "yyyy-MM-dd").toUnixInteger(),
      DateTime.fromFormat(b.data.date, "yyyy-MM-dd").toUnixInteger(),
      "bigger"
    ),
  alphabetically: (
    a: CollectionEntry<"posts">,
    b: CollectionEntry<"posts">
  ): number => {
    return sortAlphabetically(a.data.title, b.data.title);
  },
  category: (
    a: CollectionEntry<"posts">,
    b: CollectionEntry<"posts">
  ): number => {
    return sortAlphabetically(a.data.category, b.data.category);
  },
};

const { orderBy = "date", revese = false, maxPosts = 1000 } = Astro.props;
const search: string = Astro.url.searchParams.get("search") || "";

let posts = await getCollection(
  "posts",
  ({ data }: CollectionEntry<"posts">) =>
    stringIncludes(data.title, search) ||
    stringIncludes(data.category, search) ||
    stringIncludes(data.tags, search)
);

posts = posts.sort(filters[orderBy]);
posts = revese ? posts.reverse() : posts;
---

{posts.slice(0, maxPosts).map((post: any) => <BlogCard post={post} />)}
